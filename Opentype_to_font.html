<html>
  <head>
    <link rel="stylesheet" type="text/css" href="style.css" />
    <title>Opentype to font in js</title>

  </head>

  <body>
    <div class="section">
      <div class="title">Opentype to font in js</div>
    </div>

    <div class="divider"></div>
    <div class="section">
      <div class="title">Converter</div>

      <div class="content">
        <div
          id="drop-zone"
          style="
            border-radius: 8px;
            border: 2px dashed #ccc;
            padding: 40px;
            text-align: center;
          "
        >
          <p style="margin: 0px">Drag & Drop files(WOFF/OTF/TTF) here</p>
          <br />
          or
          <label for="file-upload" class="custom-file-upload">
            Choose Files
          </label>
          <input id="file-upload" type="file" multiple />
          <div id="file-list"></div>
          <div id="convert-button">Convert Files</div>
        </div>
      </div>
    </div>

    <div class="divider"></div>
    <div class="section">
      <div class="title">About</div>

      <div class="content">
        <div class="copy_container">
          This is a font conversion tool written in javascript. The script uses
          <i>Opentype</i> library to load font files from a specific directory,
          and then creates an array of objects that represent the data for each
          font. When using the exported file, be sure to declare the array as a
          variable. <br /><br />
          Download converted JSON file in JS as...
        </div>
        <br />

      </div>
    </div>

    <div class="divider"></div>
    <div class="section">
      <div class="title">What is in the file?</div>
      <div class="content">
        <div class="copy_container">
          <div class="list">
            <div class="num">1.</div>
            <div class="item">
              The array comprises objects, each corresponding to a specific font
              weight.
            </div>
          </div>

          <div class="list">
            <div class="num">2.</div>
            <div class="item">
              Within each object, there are two main components:
              <i>Parameters</i> and <i>Letters.</i>
            </div>
          </div>

          <div class="list">
            <div class="num">3.</div>
            <div class="item">
              The <i>Parameters</i> section holds structural details, including
              values for ascender, descender, etc. Additionally, there is an
              <i>Info</i> array containing objects pertaining to individual
              letters. An example of these parameters is as follows:
              <br />
              <div class="example_holder">
                Ascender: 818
                <br />
                Baseline: 0
                <br />
                Cap Height: 715
                <br />
                Descender: -182
                <br />
                Italic Angle: 0
                <br />
                Name: "Helvetica Medium"
                <br />
                X-Height: 517
              </div>
            </div>
          </div>

          <div class="list">
            <div class="num">4.</div>
            <div class="item">
              The <i>Letters</i> section encompasses two types of objects:
              <i>Info</i> and
              <i>Path.</i>
            </div>
          </div>

          <div class="list">
            <div class="num">a.</div>
            <div class="item">
              <i>Info</i> provides specific information about a given letter.
              This includes properties such as advance width, index, left-side
              bearing, Unicode value, etc. For instance:
              <br />
              <div class="example_holder">
                Advance Width: 602
                <br />
                Index: 22
                <br />
                Left-side Bearing: 67
                <br />
                Name: "K"
                <br />
                Unicode: 75
              </div>
            </div>
          </div>

          <div class="list">
            <div class="num">b.</div>
            <div class="item">
              The <i>Path</i> object contains an array of paths required to draw
              the letter. For each element in this array, a path is used to
              depict the letter's shape. If there are multiple arrays, they
              represent distinct paths. This can include paths that define both
              the letter itself and the negative space within letters like
              <i>R</i> or <i>B.</i> For example, if an array holds four
              elements, it signifies four paths utilized to create the letter.
              <br /><br />
              This structure facilitates the organization of font-related
              information into a clear and manageable format.
            </div>
          </div>

          <div class="list">
            <div class="num">5.</div>
            <div class="item">
              To view the actual example, view the browser in inspect mode to
              see the console.
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="divider"></div>
    <div class="section">
      <div class="title">Last updated</div>
      <div class="content">
        <div class="copy_container">May 30, 2024</div>
      </div>
    </div>

    <script src="js/opentype.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        const dropZone = document.getElementById("drop-zone");
        const fileList = document.getElementById("file-list");

        const convertButton = document.getElementById("convert-button");
        const fileInput = document.getElementById("file-upload");

        var filesArray = [];
        let letter_con = [];
        let buffer_con = [];

        // Prevent default drag behaviors
        ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
          dropZone.addEventListener(eventName, preventDefaults, false);
          document.body.addEventListener(eventName, preventDefaults, false);
        });

        // Highlight drop zone when dragging over it
        ["dragenter", "dragover"].forEach((eventName) => {
          dropZone.addEventListener(eventName, highlight, false);
        });

        ["dragleave", "drop"].forEach((eventName) => {
          dropZone.addEventListener(eventName, unhighlight, false);
        });

        // Handle dropped files
        dropZone.addEventListener("drop", handleDrop, false);

        fileInput.addEventListener("change", function () {
          handleFiles(this.files);
        });

        function preventDefaults(e) {
          e.preventDefault();
          e.stopPropagation();
        }

        function highlight() {
          dropZone.style.background = "#e1e7f0";
        }

        function unhighlight() {
          dropZone.style.background = "#f0f0f0";
        }

        function handleDrop(e) {
          const dt = e.dataTransfer;
          const files = dt.files;

          handleFiles(files);
        }

        function handleFiles(files) {
          [...files].forEach((file) => {
            if (!filesArray.includes(file)) {
              filesArray.push(file);
              uploadFile(file);
            }
          });
          toggleConvertButton();
        }

        function uploadFile(file) {
          const url = "YOUR_UPLOAD_URL_HERE"; // Replace with your upload URL
          const formData = new FormData();
          formData.append("file", file);

          const file_item = document.createElement("div");
          file_item.setAttribute("id", "file_item");
          file_item.innerHTML = `<p class='file_name'>${file.name}</p>`;

          const deleteButton = document.createElement("img");
          deleteButton.setAttribute("id", "delete");
          deleteButton.src = "assets/delete.svg";
          file_item.appendChild(deleteButton);

          fileList.appendChild(file_item);

          file_item.querySelector("#delete").addEventListener("click", () => {
            file_item.remove();
            filesArray = filesArray.filter((f) => f !== file);
            toggleConvertButton();

            convert_update(); //making sure it updates when files are removed
          });

          convert_update();
        }

        function toggleConvertButton() {
          if (filesArray.length > 0) {
            convertButton.style.display = "block";
          } else {
            convertButton.style.display = "none";
          }
        }

        function convert_update() {
          buffer_con = [];
          letter_con = [];

          for (let i = 0; i < filesArray.length; i++) {
            buffer_con[i] = filesArray[i].arrayBuffer();

            buffer_con[i].then((data) => {
              let font = opentype.parse(data);
              letter_con[i] = font;
            });
          }
        }

        convertButton.addEventListener("click", function () {
          for (let i = 0; i < letter_con.length; i++) {
            ccnvert_1(letter_con[i]);
          }
        });

        function ccnvert_1(font) {
          let font_to_export_arr = [];
          let letter_path_con = [];

          for (let i = 0; i < Object.keys(font.glyphs.glyphs).length; i++) {
            letter_path_con[i] = font.glyphs.glyphs[i].path.commands;
          }

          font_to_export_arr = {
            parameters: {
              name: font.names.fullName.en,
              ascender: font.tables.os2.sTypoAscender,
              cap_height: font.tables.os2.sCapHeight,
              x_height: font.tables.os2.sxHeight,
              baseline: 0,
              descender: font.tables.os2.sTypoDescender,
              italic_angle: font.tables.post.italicAngle,
            },
            letters: {
              info: font.glyphs.glyphs,
              path: letter_path_con,
            },
          };

          let path_converted_arr = path_convert(font_to_export_arr).letter_reconstructed_con;

          for (let i = 0; i < font_to_export_arr.length; i++) {
            for (let j = 0; j < Object.entries(font_to_export_arr[i].letters.path).length; j++) {
              font_to_export_arr[i].letters.path = path_converted_arr[i];
            }
          }

          console.log("Array");
          console.log("path_converted_arr");
          console.log(path_converted_arr);
          console.log("font_to_export_arr");
          console.log(font_to_export_arr);

          function downloadJSON_arr() {
            const json = "var " + name + "_Arr = " + JSON.stringify(font_to_export_arr);
            const blob = new Blob([json], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = name + "_data_arr.js";
            link.click();
          }
        }

        function path_convert(font_before_export) {
          let letter_con = [];
          let letter_reconstructed_con = [];
          let num_of_lines_con = [];
          let line_index_con = [];

          for (let i = 0; i < Object.entries(font_before_export.letters.path).length; i++) {
            line_index_con[i] = 0;
            num_of_lines_con[i] = 0;

            for (let a = 0; a < Object.entries(font_before_export.letters.path[i]).length; a++) {
              if (font_before_export.letters.path[i][a].type == "Z") {
                num_of_lines_con[i]++;
              }
            }
          }

          for (let i = 0; i < Object.entries(font_before_export.letters.path).length; i++) {
            letter_con[i] = [];
            letter_reconstructed_con[i] = [];

            for (let a = 0; a < num_of_lines_con[i]; a++) {
              letter_con[i][a] = [];
              letter_reconstructed_con[i][a] = [];
            }
          }

          for (let i = 0; i < Object.entries(font_before_export.letters.path).length; i++) {
            for (let a = 0; a < font_before_export.letters.path[i].length; a++) {
              if (font_before_export.letters.path[i][a].type !== "Z") {
                letter_con[i][line_index_con[i]].push(font_before_export.letters.path[i][a]);
              } else {
                letter_con[i][line_index_con[i]].push(font_before_export.letters.path[i][a]);
                line_index_con[i]++;
              }
            }
          }

          for (let a = 0; a < letter_con.length; a++) {
            for (let n = 0; n < letter_con[a].length; n++) {
              for (let x = 0; x < letter_con[a][n].length; x++) {

                letter_reconstructed_con[a][n][x] = {};

                if (letter_con[a][n][x].type == "M") {
                  letter_reconstructed_con[a][n][x].x = letter_con[a][n][x].x;
                  letter_reconstructed_con[a][n][x].y = letter_con[a][n][x].y;
                  letter_reconstructed_con[a][n][x].in_x = letter_con[a][n][x].x;
                  letter_reconstructed_con[a][n][x].in_y = letter_con[a][n][x].y;
                  letter_reconstructed_con[a][n][x].out_x = letter_con[a][n][x].x;
                  letter_reconstructed_con[a][n][x].out_y = letter_con[a][n][x].y;
                }

                if (letter_con[a][n][x].type == "C") {
                  if (letter_con[a][n][x + 1].type == "Z") {
                    letter_reconstructed_con[a][n][x].x = letter_con[a][n][x].x;
                    letter_reconstructed_con[a][n][x].y = letter_con[a][n][x].y;
                    letter_reconstructed_con[a][n][x - 1].out_x = letter_con[a][n][x].x1;
                    letter_reconstructed_con[a][n][x - 1].out_y = letter_con[a][n][x].y1;

                    if (letter_reconstructed_con[a][n][x].x !== letter_reconstructed_con[a][n][0].x) {
                      letter_reconstructed_con[a][n][x].in_x = letter_con[a][n][x].x2;
                      letter_reconstructed_con[a][n][x].in_y = letter_con[a][n][x].y2;
                      letter_reconstructed_con[a][n][x].out_x = letter_con[a][n][x].x;
                      letter_reconstructed_con[a][n][x].out_y = letter_con[a][n][x].y;
                    } else {
                      letter_reconstructed_con[a][n][0].in_x = letter_con[a][n][x].x2;
                      letter_reconstructed_con[a][n][0].in_y = letter_con[a][n][x].y2;
                    }
                  } else {
                    letter_reconstructed_con[a][n][x].x = letter_con[a][n][x].x;
                    letter_reconstructed_con[a][n][x].y = letter_con[a][n][x].y;
                    letter_reconstructed_con[a][n][x].in_x = letter_con[a][n][x].x2;
                    letter_reconstructed_con[a][n][x].in_y = letter_con[a][n][x].y2;
                    letter_reconstructed_con[a][n][x - 1].out_x = letter_con[a][n][x].x1;
                    letter_reconstructed_con[a][n][x - 1].out_y = letter_con[a][n][x].y1;
                  }
                }

                if (letter_con[a][n][x].type == "L") {
                  if (letter_con[a][n][x - 1].type == "C") {
                    letter_reconstructed_con[a][n][x].x = letter_con[a][n][x].x;
                    letter_reconstructed_con[a][n][x].y = letter_con[a][n][x].y;
                    letter_reconstructed_con[a][n][x].in_x = letter_con[a][n][x].x;
                    letter_reconstructed_con[a][n][x].in_y = letter_con[a][n][x].y;
                    letter_reconstructed_con[a][n][x - 1].out_x = letter_con[a][n][x].x;
                    letter_reconstructed_con[a][n][x - 1].out_y = letter_con[a][n][x].y;
                    letter_reconstructed_con[a][n][x].out_x = letter_con[a][n][x].x;
                    letter_reconstructed_con[a][n][x].out_y = letter_con[a][n][x].y;
                  } else {
                    letter_reconstructed_con[a][n][x].x = letter_con[a][n][x].x;
                    letter_reconstructed_con[a][n][x].y = letter_con[a][n][x].y;
                    letter_reconstructed_con[a][n][x].in_x = letter_con[a][n][x].x;
                    letter_reconstructed_con[a][n][x].in_y = letter_con[a][n][x].y;
                    letter_reconstructed_con[a][n][x].out_x = letter_con[a][n][x].x;
                    letter_reconstructed_con[a][n][x].out_y = letter_con[a][n][x].y;
                  }
                }
              }
            }
          }

          for (let a = 0; a < letter_con.length; a++) {
            for (let n = 0; n < letter_con[a].length; n++) {
              if (letter_con[a][n][letter_con[a][n].length - 2].x ==letter_con[a][n][0].x && letter_con[a][n][letter_con[a][n].length - 2].y ==letter_con[a][n][0].y) {
                letter_reconstructed_con[a][n].splice(-2);
              } else {
                letter_reconstructed_con[a][n].splice(-1);
              }
            }
          }

          let path_num_property_con = [];

          let point_num_property_con = [];

          for (let j = 0; j < letter_reconstructed_con.length; j++) {
            path_num_property_con[j] = [];
            point_num_property_con[j] = [];
            for (let k = 0; k < letter_reconstructed_con[j].length; k++) {
              path_num_property_con[j].push("path_" + k);
              point_num_property_con[j][k] = [];
              for (let x = 0; x < letter_reconstructed_con[j][k].length; x++) {
                point_num_property_con[j][k].push("p" + x);
              }
            }
          }

          function convert(t) {

            let paths_test = {};

            for (let i = 0; i < path_num_property_con[t].length; i++) {
              let pathName = path_num_property_con[t][i];
              let pathPoints = {};

              for (let j = 0; j < point_num_property_con[t][i].length; j++) {
                let pointName = point_num_property_con[t][i][j];
                pathPoints[pointName] = letter_reconstructed_con[t][i][j];
              }

              paths_test[pathName] = pathPoints;
            }

            return paths_test;
          }

          let letter_path_con = [];

          for (let i = 0; i < path_num_property_con.length; i++) {
            letter_path_con.push(convert(i));
          }

          console.log(letter_path_con);
          console.log(letter_reconstructed_con);

          return { letter_path_con, letter_reconstructed_con };
        }
      });
    </script>
  </body>
</html>
